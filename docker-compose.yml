version: '3.8'  # Specify the Docker Compose version

services:

## ╔═══════════════════════╗
## ║     MySQL database     ║
## ╚═══════════════════════╝

  mysql:
    image: mysql:latest  # Use the latest MySQL image
    container_name: mysql  # Name the container
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}  # Set the root password
      MYSQL_DATABASE: ${MYSQL_DATABASE}  # Create a default database
      MYSQL_USERNAME: ${MYSQL_USERNAME}  # Create a default user
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}  # Set the password for the default user
      MYSQL_BACKEND_PORT: ${MYSQL_BACKEND_PORT}  # Environment variables
    volumes:
      - mysql_data:/var/lib/mysql  # Persist MySQL data
      - ./mysql/ime_app_init.sql:/docker-entrypoint-initdb.d/ime_app_init.sql  # Initialization scripts
      - ./mysql/ime_app_mysql.cnf:/etc/mysql/ime_app_mysql.cnf  # Custom MySQL configuration
    networks:
      - backend_network  # Connect to the main network
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "mysql"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      traefik.enable: "true"  # Enable Traefik for this service
      traefik.http.routers.mysql.entrypoints: "web"  # Define the entry points (e.g., web, websecure)
      traefik.http.routers.mysql.priority: "10"  # Set the priority of the router
      traefik.http.routers.mysql.rule: "Host(`yourdomain.com`) && Path(`/path`)"  # Routing Rules: Host and Path-based routing
      traefik.http.middlewares.redirect-to-https.redirectscheme.scheme: "https"  # Middleware for redirection to HTTPS
      traefik.http.middlewares.auth.basicauth.users: "user:password"  # Middleware for basic authentication
      traefik.http.services.mysql.loadbalancer.method: "wrr"  # Load Balancing method (Weighted Round Robin)
      traefik.http.services.mysql.loadbalancer.server.port: "9091"  # Define the port for the load balancer
      traefik.http.services.mysql.loadbalancer.healthcheck.path: "/health"  # Set the health check path for the load balancer
      traefik.http.routers.mysql.tls: "true"  # Enable TLS for the router
      traefik.http.routers.mysql.tls.certresolver: "myresolver"  # Specify the TLS certificate resolver
      traefik.http.middlewares.custom-headers.headers.customrequestheaders.X-Forwarded-For: "client"  # Add custom headers
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - secret  # Use Docker secrets
    configs:
      - config  # Use Docker configs


## ╔════════════════════════════════╗
## ║ PHPMyAdmin for MySQL management ║
## ╚════════════════════════════════╝

  phpmyadmin:
    image: phpmyadmin/phpmyadmin:latest  # Use the latest phpMyAdmin image
    container_name: phpmyadmin  # Name the container
    environment:
        PMA_HOST: mysql  # Link to the MySQL service
        MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}  # MySQL root password
        PHPMYADMIN_BACKEND_PORT: ${PHPMYADMIN_BACKEND_PORT}  # Environment variables
        PHPMYADMIN_FRONTEND_PORT: ${PHPMYADMIN_FRONTEND_PORT}
    volumes:
      - ./phpmyadmin/sessions:/sessions  # Mount a directory for session storage
    networks:
      - backend_network  # Connect to the backend network
      - frontend_network  # Connect to the frontend network
    depends_on:
      - mysql  # Ensure this service starts after the MySQL service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "phpmyadmin"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      traefik.enable: "true"  # Enable Traefik for this service
      traefik.http.routers.phpmyadmin.entrypoints: "web && websecure"  # Define the entry points (e.g., web, websecure)
      traefik.http.routers.phpmyadmin.priority: "10"  # Set the priority of the router
      traefik.http.routers.phpmyadmin.rule: "Host(`yourdomain.com`) && Path(`/path`)"  # Routing Rules: Host and Path-based routing
      traefik.http.middlewares.redirect-to-https.redirectscheme.scheme: "https"  # Middleware for redirection to HTTPS
      traefik.http.middlewares.auth.basicauth.users: "user:password"  # Middleware for basic authentication
      traefik.http.services.phpmyadmin.loadbalancer.method: "wrr"  # Load Balancing method (Weighted Round Robin)
      traefik.http.services.phpmyadmin.loadbalancer.server.port: ${PHPMYADMIN_BACKEND_PORT}  # Define the port for the load balancer
      traefik.http.services.phpmyadmin.loadbalancer.healthcheck.path: "/health"  # Set the health check path for the load balancer
      traefik.http.routers.phpmyadmin.tls: "true"  # Enable TLS for the router
      traefik.http.routers.phpmyadmin.tls.certresolver: "myresolver"  # Specify the TLS certificate resolver
      traefik.http.middlewares.custom-headers.headers.customrequestheaders.X-Forwarded-For: "client"  # Add custom headers
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - secret  # Use Docker secrets
    configs:
      - config  # Use Docker configs


## ╔═══════════════════════╗
## ║  PostgreSQL database   ║
## ╚═══════════════════════╝

  postgres:
    image: postgres:latest  # Use the latest PostgreSQL image
    container_name: postgres  # Name the container
    environment:
      POSTGRES_DATABASE: ${POSTGRES_DATABASE}  # Create a default database
      POSTGRES_USERNAME: ${POSTGRES_USERNAME}  # Set the PostgreSQL user
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}  # Set the PostgreSQL password
      POSTGRES_BACKEND_PORT: ${POSTGRES_BACKEND_PORT}  # Environment variables
      POSTGRES_AI_PORT: ${POSTGRES_AI_PORT}
    volumes:
      - postgres_data:/var/lib/postgresql/data  # Persist PostgreSQL data
      - ./postgres/init.sql:/docker-entrypoint-initdb.d/init.sql  # Initialization scripts
      - ./postgres/postgresql.conf:/etc/postgresql/postgresql.conf  # Custom PostgreSQL configuration
    networks:
      - backend_network  # Connect to the backend network
      - ai_network  # Connect to the ai network
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      traefik.enable: "true"  # Enable Traefik for this service
      traefik.http.routers.postgres.entrypoints: "web"  # Define the entry points (e.g., web, websecure)
      traefik.http.routers.postgres.priority: "10"  # Set the priority of the router
      traefik.http.routers.postgres.rule: "Host(`yourdomain.com`) && Path(`/path`)"  # Routing Rules: Host and Path-based routing
      traefik.http.middlewares.redirect-to-https.redirectscheme.scheme: "https"  # Middleware for redirection to HTTPS
      traefik.http.middlewares.auth.basicauth.users: "user:password"  # Middleware for basic authentication
      traefik.http.services.postgres.loadbalancer.method: "wrr"  # Load Balancing method (Weighted Round Robin)
      traefik.http.services.postgres.loadbalancer.server.port: ${POSTGRES_BACKEND_PORT}  # Define the port for the load balancer
      traefik.http.services.postgres.loadbalancer.healthcheck.path: "/health"  # Set the health check path for the load balancer
      traefik.http.routers.postgres.tls: "true"  # Enable TLS for the router
      traefik.http.routers.postgres.tls.certresolver: "myresolver"  # Specify the TLS certificate resolver
      traefik.http.middlewares.custom-headers.headers.customrequestheaders.X-Forwarded-For: "client"  # Add custom headers
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - secret  # Use Docker secrets
    configs:
      - config  # Use Docker configs


## ╔═══════════════════════╗
## ║       Project 1        ║
## ║ backend-api Container  ║
## ╚═══════════════════════╝

  backend-api:
    build:
      context: /home/app-source/backend-api  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: backend-api  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    environment:
      BACKEND_API_BACKEND_PORT: ${BACKEND_API_BACKEND_PORT}
      BACKEND_API_FRONTEND_PORT: ${BACKEND_API_BACKEND_PORT}
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
      - backend_network  # Connect to the backend network
      - frontend_network  # Connect to the frontend network
      - ai_network  # Connect to the ai network
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "backend-api"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      traefik.enable: "true"  # Enable Traefik for this service
      traefik.http.routers.backend-api.entrypoints: "web"  # Define the entry points (e.g., web, websecure)
      traefik.http.routers.backend-api.priority: "10"  # Set the priority of the router
      traefik.http.routers.backend-api.rule: "Host(`yourdomain.com`) && Path(`/path`)"  # Routing Rules: Host and Path-based routing
      traefik.http.middlewares.redirect-to-https.redirectscheme.scheme: "https"  # Middleware for redirection to HTTPS
      traefik.http.middlewares.auth.basicauth.users: "user:password"  # Middleware for basic authentication
      traefik.http.services.backend-api.loadbalancer.method: "wrr"  # Load Balancing method (Weighted Round Robin)
      traefik.http.services.backend-api.loadbalancer.server.port: ${BACKEND_API_BACKEND_PORT}  # Define the port for the load balancer
      traefik.http.services.backend-api.loadbalancer.healthcheck.path: "/health"  # Set the health check path for the load balancer
      traefik.http.routers.backend-api.tls: "true"  # Enable TLS for the router
      traefik.http.routers.backend-api.tls.certresolver: "myresolver"  # Specify the TLS certificate resolver
      traefik.http.middlewares.custom-headers.headers.customrequestheaders.X-Forwarded-For: "client"  # Add custom headers
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - secret  # Use Docker secrets
    configs:
      - config  # Use Docker configs


## ╔═══════════════════════╗
## ║       Project 2        ║
## ║ home-domain Container  ║
## ╚═══════════════════════╝

  home-domain:
    build:
      context: /home/app-source/home-domain  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: home-domain  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    environment:
      HOME_DOMAIN_BACKEND_PORT: ${HOME_DOMAIN_BACKEND_PORT}
      HOME_DOMAIN_FRONTEND_PORT: ${HOME_DOMAIN_FRONTEND_PORT}
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
      - backend_network  # Connect to the backend network
      - frontend_network  # Connect to the frontend network
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "home-domain"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      traefik.enable: "true"  # Enable Traefik for this service
      traefik.http.routers.home-domain.entrypoints: "web"  # Define the entry points (e.g., web, websecure)
      traefik.http.routers.home-domain.priority: "10"  # Set the priority of the router
      traefik.http.routers.home-domain.rule: "Host(`yourdomain.com`) && Path(`/path`)"  # Routing Rules: Host and Path-based routing
      traefik.http.middlewares.redirect-to-https.redirectscheme.scheme: "https"  # Middleware for redirection to HTTPS
      traefik.http.middlewares.auth.basicauth.users: "user:password"  # Middleware for basic authentication
      traefik.http.services.home-domain.loadbalancer.method: "wrr"  # Load Balancing method (Weighted Round Robin)
      traefik.http.services.home-domain.loadbalancer.server.port: ${HOME_DOMAIN_BACKEND_PORT}  # Define the port for the load balancer
      traefik.http.services.home-domain.loadbalancer.healthcheck.path: "/health"  # Set the health check path for the load balancer
      traefik.http.routers.home-domain.tls: "true"  # Enable TLS for the router
      traefik.http.routers.home-domain.tls.certresolver: "myresolver"  # Specify the TLS certificate resolver
      traefik.http.middlewares.custom-headers.headers.customrequestheaders.X-Forwarded-For: "client"  # Add custom headers
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - secret  # Use Docker secrets
    configs:
      - config  # Use Docker configs


## ╔═══════════════════════╗
## ║       Project 3        ║
## ║  dashboard Container   ║
## ╚═══════════════════════╝

  dashboard:
    build:
      context: /home/app-source/dashboard  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: dashboard  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    environment:
      DASHBOARD_BACKEND_PORT: ${DASHBOARD_BACKEND_PORT}
      DASHBOARD_FRONTEND_PORT: ${DASHBOARD_FRONTEND_PORT}
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
    - backend_network  # Connect to the backend network
    - frontend_network  # Connect to the frontend network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "dashboard"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      traefik.enable: "true"  # Enable Traefik for this service
      traefik.http.routers.dashboard.entrypoints: "web"  # Define the entry points (e.g., web, websecure)
      traefik.http.routers.dashboard.priority: "10"  # Set the priority of the router
      traefik.http.routers.dashboard.rule: "Host(`yourdomain.com`) && Path(`/path`)"  # Routing Rules: Host and Path-based routing
      traefik.http.middlewares.redirect-to-https.redirectscheme.scheme: "https"  # Middleware for redirection to HTTPS
      traefik.http.middlewares.auth.basicauth.users: "user:password"  # Middleware for basic authentication
      traefik.http.services.dashboard.loadbalancer.method: "wrr"  # Load Balancing method (Weighted Round Robin)
      traefik.http.services.dashboard.loadbalancer.server.port: ${DASHBOARD_BACKEND_PORT}  # Define the port for the load balancer
      traefik.http.services.dashboard.loadbalancer.healthcheck.path: "/health"  # Set the health check path for the load balancer
      traefik.http.routers.dashboard.tls: "true"  # Enable TLS for the router
      traefik.http.routers.dashboard.tls.certresolver: "myresolver"  # Specify the TLS certificate resolver
      traefik.http.middlewares.custom-headers.headers.customrequestheaders.X-Forwarded-For: "client"  # Add custom headers
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - secret  # Use Docker secrets
    configs:
      - config  # Use Docker configs


## ╔═══════════════════════╗
## ║       Project 4        ║
## ║     blog Container     ║
## ╚═══════════════════════╝

  blog:
    build:
      context: /home/app-source/blog  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: blog  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    environment:
      BLOG_BACKEND_PORT: ${BLOG_BACKEND_PORT}
      BLOG_FRONTEND_PORT: ${BLOG_FRONTEND_PORT}
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
    - backend_network  # Connect to the backend network
    - frontend_network  # Connect to the frontend network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "blog"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      traefik.enable: "true"  # Enable Traefik for this service
      traefik.http.routers.blog.entrypoints: "web"  # Define the entry points (e.g., web, websecure)
      traefik.http.routers.blog.priority: "10"  # Set the priority of the router
      traefik.http.routers.blog.rule: "Host(`yourdomain.com`) && Path(`/path`)"  # Routing Rules: Host and Path-based routing
      traefik.http.middlewares.redirect-to-https.redirectscheme.scheme: "https"  # Middleware for redirection to HTTPS
      traefik.http.middlewares.auth.basicauth.users: "user:password"  # Middleware for basic authentication
      traefik.http.services.blog.loadbalancer.method: "wrr"  # Load Balancing method (Weighted Round Robin)
      traefik.http.services.blog.loadbalancer.server.port: ${BLOG_BACKEND_PORT}  # Define the port for the load balancer
      traefik.http.services.blog.loadbalancer.healthcheck.path: "/health"  # Set the health check path for the load balancer
      traefik.http.routers.blog.tls: "true"  # Enable TLS for the router
      traefik.http.routers.blog.tls.certresolver: "myresolver"  # Specify the TLS certificate resolver
      traefik.http.middlewares.custom-headers.headers.customrequestheaders.X-Forwarded-For: "client"  # Add custom headers
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - secret  # Use Docker secrets
    configs:
      - config  # Use Docker configs


## ╔═══════════════════════╗
## ║       Project 5        ║
## ║   solutions Container  ║
## ╚═══════════════════════╝

  solutions:
    build:
      context: /home/app-source/solutions  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: solutions  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    environment:
      SOLUTIONS_BACKEND_PORT: ${SOLUTIONS_BACKEND_PORT}
      SOLUTIONS_FRONTEND_PORT: ${SOLUTIONS_FRONTEND_PORT}
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
    - backend_network  # Connect to the backend network
    - frontend_network  # Connect to the frontend network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "solutions"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      traefik.enable: "true"  # Enable Traefik for this service
      traefik.http.routers.solutions.entrypoints: "web"  # Define the entry points (e.g., web, websecure)
      traefik.http.routers.solutions.priority: "10"  # Set the priority of the router
      traefik.http.routers.solutions.rule: "Host(`yourdomain.com`) && Path(`/path`)"  # Routing Rules: Host and Path-based routing
      traefik.http.middlewares.redirect-to-https.redirectscheme.scheme: "https"  # Middleware for redirection to HTTPS
      traefik.http.middlewares.auth.basicauth.users: "user:password"  # Middleware for basic authentication
      traefik.http.services.solutions.loadbalancer.method: "wrr"  # Load Balancing method (Weighted Round Robin)
      traefik.http.services.solutions.loadbalancer.server.port: ${SOLUTIONS_BACKEND_PORT}  # Define the port for the load balancer
      traefik.http.services.solutions.loadbalancer.healthcheck.path: "/health"  # Set the health check path for the load balancer
      traefik.http.routers.solutions.tls: "true"  # Enable TLS for the router
      traefik.http.routers.solutions.tls.certresolver: "myresolver"  # Specify the TLS certificate resolver
      traefik.http.middlewares.custom-headers.headers.customrequestheaders.X-Forwarded-For: "client"  # Add custom headers
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - secret  # Use Docker secrets
    configs:
      - config  # Use Docker configs


## ╔═══════════════════════╗
## ║       Project 6        ║
## ║     ??? Container      ║
## ╚═══════════════════════╝


## ╔═══════════════════════╗
## ║       Project 7        ║
## ║     ??? Container      ║
## ╚═══════════════════════╝


## ╔═══════════════════════╗
## ║       Project 8        ║
## ║  ime-agent Container   ║
## ╚═══════════════════════╝

  ime-agent:
    build:
      context: /home/app-source/ime-agent  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: ime-agent  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    environment:
      MODEL_PATH: "/home/app-source/ime-agent/models/ime_model"  # Environment variables
      IME_AGENT_BACKEND_PORT: ${IME_AGENT_BACKEND_PORT}
      IME_AGENT_FRONTEND_PORT: ${IME_AGENT_FRONTEND_PORT}
      IME_AGENT_AI_PORT: ${IME_AGENT_AI_PORT}
    volumes:
      - ime_model_data:/home/app-source/ime-agent/models  # Mount host directories or files
    networks:
      - ai_network  # Connect to the ai network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "ime-agent"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      traefik.enable: "true"  # Enable Traefik for this service
      traefik.http.routers.ime-agent.entrypoints: "web"  # Define the entry points (e.g., web, websecure)
      traefik.http.routers.ime-agent.priority: "10"  # Set the priority of the router
      traefik.http.routers.ime-agent.rule: "Host(`yourdomain.com`) && Path(`/path`)"  # Routing Rules: Host and Path-based routing
      traefik.http.middlewares.redirect-to-https.redirectscheme.scheme: "https"  # Middleware for redirection to HTTPS
      traefik.http.middlewares.auth.basicauth.users: "user:password"  # Middleware for basic authentication
      traefik.http.services.ime-agent.loadbalancer.method: "wrr"  # Load Balancing method (Weighted Round Robin)
      traefik.http.services.ime-agent.loadbalancer.server.port: ${IME_AGENT_BACKEND_PORT}  # Define the port for the load balancer
      traefik.http.services.ime-agent.loadbalancer.healthcheck.path: "/health"  # Set the health check path for the load balancer
      traefik.http.routers.ime-agent.tls: "true"  # Enable TLS for the router
      traefik.http.routers.ime-agent.tls.certresolver: "myresolver"  # Specify the TLS certificate resolver
      traefik.http.middlewares.custom-headers.headers.customrequestheaders.X-Forwarded-For: "client"  # Add custom headers
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '4'  # CPU limit
          memory: 8G  # Memory limit
        reservations:
          cpus: '2'  # CPU reservation
          memory: 4G  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - secret  # Use Docker secrets
    configs:
      - config  # Use Docker configs


## ╔═══════════════════════╗
## ║       Project 9        ║
## ║     wiki Container     ║
## ╚═══════════════════════╝

  wiki:
    build:
      context: /home/app-source/wiki  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: wiki  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    environment:
      WIKI_BACKEND_PORT: ${WIKI_BACKEND_PORT}
      WIKI_FRONTEND_PORT: ${WIKI_FRONTEND_PORT}
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
      - backend_network  # Connect to the backend network
      - frontend_network  # Connect to the frontend network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "wiki"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      traefik.enable: "true"  # Enable Traefik for this service
      traefik.http.routers.wiki.entrypoints: "web"  # Define the entry points (e.g., web, websecure)
      traefik.http.routers.wiki.priority: "10"  # Set the priority of the router
      traefik.http.routers.wiki.rule: "Host(`yourdomain.com`) && Path(`/path`)"  # Routing Rules: Host and Path-based routing
      traefik.http.middlewares.redirect-to-https.redirectscheme.scheme: "https"  # Middleware for redirection to HTTPS
      traefik.http.middlewares.auth.basicauth.users: "user:password"  # Middleware for basic authentication
      traefik.http.services.wiki.loadbalancer.method: "wrr"  # Load Balancing method (Weighted Round Robin)
      traefik.http.services.wiki.loadbalancer.server.port: ${WIKI_BACKEND_PORT}  # Define the port for the load balancer
      traefik.http.services.wiki.loadbalancer.healthcheck.path: "/health"  # Set the health check path for the load balancer
      traefik.http.routers.wiki.tls: "true"  # Enable TLS for the router
      traefik.http.routers.wiki.tls.certresolver: "myresolver"  # Specify the TLS certificate resolver
      traefik.http.middlewares.custom-headers.headers.customrequestheaders.X-Forwarded-For: "client"  # Add custom headers
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - secret  # Use Docker secrets
    configs:
      - config  # Use Docker configs


## ╔═══════════════════════╗
## ║       Project 10       ║
## ║    sample Container    ║
## ╚═══════════════════════╝


## ╔═══════════════════════╗
## ║      Project 11        ║
## ║   ime-nft Container    ║
## ╚═══════════════════════╝

  ime-nft:
    build:
      context: /home/app-source/ime-nft  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: ime-nft  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    environment:
      IME_NFT_BACKEND_PORT: ${IME_NFT_BACKEND_PORT}
      IME_NFT_FRONTEND_PORT: ${IME_NFT_FRONTEND_PORT}
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
      - backend_network  # Connect to the backend network
      - frontend_network  # Connect to the frontend network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "ime-nft"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      traefik.enable: "true"  # Enable Traefik for this service
      traefik.http.routers.ime-nft.entrypoints: "web"  # Define the entry points (e.g., web, websecure)
      traefik.http.routers.ime-nft.priority: "10"  # Set the priority of the router
      traefik.http.routers.ime-nft.rule: "Host(`yourdomain.com`) && Path(`/path`)"  # Routing Rules: Host and Path-based routing
      traefik.http.middlewares.redirect-to-https.redirectscheme.scheme: "https"  # Middleware for redirection to HTTPS
      traefik.http.middlewares.auth.basicauth.users: "user:password"  # Middleware for basic authentication
      traefik.http.servicesime-nft.loadbalancer.method: "wrr"  # Load Balancing method (Weighted Round Robin)
      traefik.http.services.ime-nft.loadbalancer.server.port: ${IME_NFT_BACKEND_PORT}  # Define the port for the load balancer
      traefik.http.services.ime-nft.loadbalancer.healthcheck.path: "/health"  # Set the health check path for the load balancer
      traefik.http.routers.ime-nft.tls: "true"  # Enable TLS for the router
      traefik.http.routers.ime-nft.tls.certresolver: "myresolver"  # Specify the TLS certificate resolver
      traefik.http.middlewares.custom-headers.headers.customrequestheaders.X-Forwarded-For: "client"  # Add custom headers
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - secret  # Use Docker secrets
    configs:
      - config  # Use Docker configs


## ╔═══════════════════════╗
## ║     Traefik server     ║
## ╚═══════════════════════╝

  traefik:
    image: traefik:latest  # Use the latest Traefik image
    container_name: traefik_server  # Name the container
    command:
      - "--api.insecure=true"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock  # Mount Docker socket for Traefik to communicate with Docker
      - ./traefik/traefik.yml:/etc/traefik/traefik.yml  # Mount Traefik configuration file
    networks:
      - backend_network  # Connect to the backend network
    environment:
      MYSQL_BACKEND_PORT: ${MYSQL_BACKEND_PORT}
      PHPMYADMIN_BACKEND_PORT: ${PHPMYADMIN_BACKEND_PORT}
      POSTGRES_BACKEND_PORT: ${POSTGRES_BACKEND_PORT}
      BACKEND_API_BACKEND_PORT: ${BACKEND_API_BACKEND_PORT}
      HOME_DOMAIN_BACKEND_PORT: ${HOME_DOMAIN_BACKEND_PORT}
      DASHBOARD_BACKEND_PORT: ${DASHBOARD_BACKEND_PORT}
      BLOG_BACKEND_PORT: ${BLOG_BACKEND_PORT}
      SOLUTIONS_BACKEND_PORT: ${SOLUTIONS_BACKEND_PORT}
      IME_AGENT_BACKEND_PORT: ${IME_AGENT_BACKEND_PORT}
      WIKI_BACKEND_PORT: ${WIKI_BACKEND_PORT}
      IME_NFT_BACKEND_PORT: ${IME_NFT_BACKEND_PORT}
      TRAEFIK_DASHBOARD_BACKEND_PORT: ${TRAEFIK_DASHBOARD_BACKEND_PORT}
      TRAEFIK_DASHBOARD_FRONTEND_PORT: ${TRAEFIK_DASHBOARD_FRONTEND_PORT}
    depends_on:
      mysql:  # Ensure this service starts after some_other_service
        condition: service_healthy
      phpmyadmin:
        condition: service_healthy
      postgres:
        condition: service_healthy
      backend-api:
        condition: service_healthy
      home-domain:
        condition: service_healthy
      dashboard:
        condition: service_healthy
      blog:
        condition: service_healthy
      solutions:
        condition: service_healthy
      ime-agent:
        condition: service_healthy
      wiki:
        condition: service_healthy
      ime-nft:
        condition: service_healthy
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "traefik"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "Traefik Reverse Proxy"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - secret  # Use Docker secrets
    configs:
      - config  # Use Docker configs


## ╔══════════════════════════════════════════════╗
## ║       FastAPI with Gunicorn and Uvicorn       ║
## ╚══════════════════════════════════════════════╝

  fastapi-gunicorn-uvicorn:
    build:
      context: /home/app-source/fastapi-gunicorn-uvicorn  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: fastapi-gunicorn-uvicorn  # Name the container
    command: gunicorn -w 4 -k uvicorn.workers.UvicornWorker main:app  # Start Gunicorn with Uvicorn workers
    environment:
      BACKEND_API_AI_PORT: ${BACKEND_API_AI_PORT}
      IME_AGENT_AI_PORT: ${IME_AGENT_AI_PORT}
      FASTAPI_GUNICORN_UVICORN_AI_PORT: ${FASTAPI_GUNICORN_UVICORN_AI_PORT}
      MODULE_NAME: app.main
      VARIABLE_NAME: app
      WORKERS_PER_CORE: 1
      MAX_WORKERS: 1
      WEB_CONCURRENCY: 1
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
      - ai_network  # Connect to the ai network
    depends_on:
      postgres:
        condition: service_healthy
      backend-api:
        condition: service_healthy
      ime-agent:
        condition: service_healthy
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "fastapi-gunicorn-uvicorn"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "FastAPI Service"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - secret  # Use Docker secrets
    configs:
      - config  # Use Docker configs


## ╔═══════════════════════╗
## ║ Nginx as reverse proxy ║
## ╚═══════════════════════╝

  nginx_reverse_proxy:
    image: nginx:latest  # Use the latest Nginx image
    container_name: nginx_reverse_proxy  # Name the container
    ports:
      - "80:80"  # Map port 80 on the host to port 80 in the container (HTTP)
      - "443:443"  # Map port 443 on the host to port 443 in the container (HTTPS)
    volumes:
      - ./nginx/conf:/etc/nginx/conf.d  # Mount the Nginx configuration directory
      - ./nginx/certs:/etc/nginx/certs  # SSL certificates
    networks:
      - frontend_network  # Connect to the frontend network
      - ai_network  # Connect to the ai network
    environment:
      PHPMYADMIN_FRONTEND_PORT: ${PHPMYADMIN_FRONTEND_PORT}
      BACKEND_API_FRONTEND_PORT: ${BACKEND_API_FRONTEND_PORT}
      HOME_DOMAIN_FRONTEND_PORT: ${HOME_DOMAIN_FRONTEND_PORT}
      DASHBOARD_FRONTEND_PORT: ${DASHBOARD_FRONTEND_PORT}
      BLOG_FRONTEND_PORT: ${BLOG_FRONTEND_PORT}
      SOLUTIONS_FRONTEND_PORT: ${SOLUTIONS_FRONTEND_PORT}
      IME_AGENT_FRONTEND_PORT: ${IME_AGENT_FRONTEND_PORT}
      IME_AGENT_AI_PORT: ${IME_AGENT_AI_PORT}
      WIKI_FRONTEND_PORT: ${WIKI_FRONTEND_PORT}
      IME_NFT_FRONTEND_PORT: ${IME_NFT_FRONTEND_PORT}
      TRAEFIK_DASHBOARD_FRONTEND_PORT: ${TRAEFIK_DASHBOARD_FRONTEND_PORT}
      FASTAPI_GUNICORN_UVICORN_AI_PORT: ${FASTAPI_GUNICORN_UVICORN_AI_PORT}
    depends_on:
      backend-api:
        condition: service_healthy
      home-domain:
        condition: service_healthy
      dashboard:
        condition: service_healthy
      blog:
        condition: service_healthy
      solutions:
        condition: service_healthy
      ime-agent:
        condition: service_healthy
      wiki:
        condition: service_healthy
      ime-nft:
        condition: service_healthy
      fastapi-gunicorn-uvicorn:
        condition: service_healthy
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "nginx_reverse_proxy"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "Nginx Reverse Proxy"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - secret  # Use Docker secrets
    configs:
      - config  # Use Docker configs


# Define networks
networks:
  backend_network:
    driver: bridge  # Network driver
    internal: true
  ai_network:
    driver: bridge  # Network driver
    internal: true
  frontend_network:
    driver: bridge  # Network driver
    external: true

secrets:
  secret:
    file: ./secret.txt  # File containing the secret

configs:
  config:
    file: ./config.json  # File containing the configuration

# Define volumes
volumes:
  mysql_data:
  postgres_data:
  ime_model_data:
