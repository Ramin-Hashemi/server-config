version: '3.8'  # Specify the Docker Compose version

services:
## ╔═══════════════════════╗
## ║ Main Apache web server ║
## ╚═══════════════════════╝
  apache:
    image: httpd:latest  # Use the latest Apache HTTP server image
    container_name: apache_server  # Name the container
    ports:
      - "80:80"  # Map port 80 on the host to port 80 in the container (HTTP)
      - "443:443"  # Map port 443 on the host to port 443 in the container (HTTPS)
    volumes:
      - ./apache/www:/usr/local/apache2/htdocs/  # Mount the web content directory
    networks:
      - main_network  # Connect to the main network
    environment:
      - ENV_VAR1=value1  # Environment variables
      - ENV_VAR2=value2
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:80"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "Apache HTTP Server"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - my_secret  # Use Docker secrets
    configs:
      - my_config  # Use Docker configs

## ╔══════════════════════════════════════════════╗
## ║ Main FastAPI server with Gunicorn and Uvicorn ║
## ╚══════════════════════════════════════════════╝
  fastapi:
    build:
      context: /home/app-source/fastapi  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: fastapi  # Name the container
    command: gunicorn -w 4 -k uvicorn.workers.UvicornWorker main:app  # Start Gunicorn with Uvicorn workers
    ports:
      - "8080:8080"  # Map port 8080 on the host to port 8080 in the container
    environment:
      - ENV_VAR1=value1  # Environment variables
      - ENV_VAR2=value2
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
      - main_network  # Connect to the main network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "FastAPI Service"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - my_secret  # Use Docker secrets
    configs:
      - my_config  # Use Docker configs

## ╔═══════════════════════╗
## ║ Nginx as reverse proxy ║
## ╚═══════════════════════╝
  nginx_reverse_proxy:
    image: nginx:latest  # Use the latest Nginx image
    container_name: nginx_reverse_proxy  # Name the container
    ports:
      - "80:80"  # Map port 80 on the host to port 80 in the container (HTTP)
      - "443:443"  # Map port 443 on the host to port 443 in the container (HTTPS)
    volumes:
      - ./nginx/conf:/etc/nginx/conf.d  # Mount the Nginx configuration directory
      - ./nginx/certs:/etc/nginx/certs  # SSL certificates
    networks:
      - frontend_network  # Connect to the frontend network
      - backend_network  # Connect to the backend network
    environment:
      - ENV_VAR1=value1  # Environment variables
      - ENV_VAR2=value2
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:80"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "Nginx Reverse Proxy"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - my_secret  # Use Docker secrets
    configs:
      - my_config  # Use Docker configs

## ╔════════════════════════════════╗
## ║ PHPMyAdmin for MySQL management ║
## ╚════════════════════════════════╝
  phpmyadmin:
    image: phpmyadmin/phpmyadmin:latest  # Use the latest phpMyAdmin image
    container_name: phpmyadmin  # Name the container
    ports:
      - "3000:3000"  # Map port 3000 on the host to port 3000 in the container
    environment:
      PMA_HOST: mysql  # Link to the MySQL service
      MYSQL_ROOT_PASSWORD: root_password  # MySQL root password
    volumes:
      - ./phpmyadmin/sessions:/sessions  # Mount a directory for session storage
    networks:
      - main_network  # Connect to the main network
    depends_on:
      - mysql  # Ensure this service starts after the MySQL service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "phpMyAdmin Service"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - my_secret  # Use Docker secrets
    configs:
      - my_config  # Use Docker configs

## ╔═══════════════════════╗
## ║     MySQL database     ║
## ╚═══════════════════════╝
  mysql:
    image: mysql:latest  # Use the latest MySQL image
    container_name: mysql  # Name the container
    environment:
      MYSQL_ROOT_PASSWORD: root_password  # Set the root password
      MYSQL_DATABASE: mydatabase  # Create a default database
      MYSQL_USER: myuser  # Create a default user
      MYSQL_PASSWORD: mypassword  # Set the password for the default user
    ports:
      - "3306:3306"  # Map port 3306 on the host to port 3306 in the container
    volumes:
      - mysql_data:/var/lib/mysql  # Persist MySQL data
      - ./mysql/init.sql:/docker-entrypoint-initdb.d/init.sql  # Initialization scripts
      - ./mysql/my.cnf:/etc/mysql/my.cnf  # Custom MySQL configuration
    networks:
      - main_network  # Connect to the main network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "MySQL Database Service"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - my_secret  # Use Docker secrets
    configs:
      - my_config  # Use Docker configs

## ╔═══════════════════════╗
## ║  PostgreSQL database   ║
## ╚═══════════════════════╝
  postgres:
    image: postgres:latest  # Use the latest PostgreSQL image
    container_name: postgres  # Name the container
    environment:
      POSTGRES_USER: postgres_user  # Set the PostgreSQL user
      POSTGRES_PASSWORD: postgres_password  # Set the PostgreSQL password
      POSTGRES_DB: postgres_db  # Create a default database
    ports:
      - "5432:5432"  # Map port 5432 on the host to port 5432 in the container
    volumes:
      - postgres_data:/var/lib/postgresql/data  # Persist PostgreSQL data
      - ./postgres/init.sql:/docker-entrypoint-initdb.d/init.sql  # Initialization scripts
      - ./postgres/postgresql.conf:/etc/postgresql/postgresql.conf  # Custom PostgreSQL configuration
    networks:
      - main_network  # Connect to the main network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres_user"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "PostgreSQL Database Service"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - my_secret  # Use Docker secrets
    configs:
      - my_config  # Use Docker configs

## ╔═══════════════════════╗
## ║       Project 1        ║
## ║ backend-api Container  ║
## ╚═══════════════════════╝
  backend-api:
    build:
      context: /home/app-source/backend-api  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: backend-api  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    ports:
      - "8001:8001"  # Map port 8001 on the host to port 8001 in the container
    environment:
      - ENV_VAR1=value1  # Environment variables
      - ENV_VAR2=value2
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
      - project_network  # Connect to the project network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8001"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "Backend API Service"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - my_secret  # Use Docker secrets
    configs:
      - my_config  # Use Docker configs

## ╔═══════════════════════╗
## ║       Project 2        ║
## ║ home-domain Container  ║
## ╚═══════════════════════╝
  home-domain:
    build:
      context: /home/app-source/home-domain  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: home-domain  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    ports:
      - "8002:8002"  # Map port 8002 on the host to port 8002 in the container
    environment:
      - ENV_VAR1=value1  # Environment variables
      - ENV_VAR2=value2
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
      - project_network  # Connect to the project network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8002"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "Home Domain Service"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - my_secret  # Use Docker secrets
    configs:
      - my_config  # Use Docker configs

## ╔═══════════════════════╗
## ║       Project 3        ║
## ║  dashboard Container   ║
## ╚═══════════════════════╝
  dashboard:
      build:
        context: /home/app-source/dashboard  # Build context
        dockerfile: Dockerfile  # Specify an alternate Dockerfile
        args:
          - BUILD_ENV=production  # Build arguments
      container_name: dashboard  # Name the container
      command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
      ports:
        - "8003:8003"  # Map port 8003 on the host to port 8003 in the container
      environment:
        - ENV_VAR1=value1  # Environment variables
        - ENV_VAR2=value2
      volumes:
        - /host/path:/container/path  # Mount host directories or files
      networks:
        - project_network  # Connect to the project network
      depends_on:
        - some_other_service  # Ensure this service starts after some_other_service
      restart: always  # Restart policy (no, on-failure, always, unless-stopped)
      logging:
        driver: "json-file"  # Logging driver
        options:
          max-size: "10m"  # Maximum log file size
          max-file: "3"  # Maximum number of log files
      healthcheck:
        test: ["CMD", "curl", "-f", "http://localhost:8003"]  # Command to check service health
        interval: 1m  # Time between checks
        timeout: 10s  # Time before considering the check failed
        retries: 3  # Number of retries before marking the service as unhealthy
      labels:
        com.example.description: "Dashboard Service"  # Custom metadata labels
      deploy:
        replicas: 2  # Number of container instances
        resources:
          limits:
            cpus: '0.5'  # CPU limit
            memory: 512M  # Memory limit
          reservations:
            cpus: '0.25'  # CPU reservation
            memory: 256M  # Memory reservation
        restart_policy:
          condition: on-failure  # Restart policy condition
          delay: 5s  # Delay before restarting
          max_attempts: 3  # Maximum number of restart attempts
          window: 120s  # Time window for restart attempts
        placement:
          constraints:
            - node.role == manager  # Placement constraints
        update_config:
          parallelism: 2  # Number of containers to update at a time
          delay: 10s  # Delay between updates
          order: start-first  # Update order
        rollback_config:
          parallelism: 2  # Number of containers to rollback at a time
          delay: 10s  # Delay between rollbacks
      extra_hosts:
        - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
      dns:
        - 8.8.8.8  # Custom DNS servers
        - 8.8.4.4
      dns_search:
        - example.com  # Custom DNS search domains
      ulimits:
        nproc: 65535  # Set ulimits for the container
        nofile:
          soft: 20000
          hard: 40000
      cap_add:
        - NET_ADMIN  # Add Linux capabilities
      cap_drop:
        - MKNOD  # Drop Linux capabilities
      secrets:
        - my_secret  # Use Docker secrets
      configs:
        - my_config  # Use Docker configs

## ╔═══════════════════════╗
## ║       Project 4        ║
## ║     blog Container     ║
## ╚═══════════════════════╝
  blog:
      build:
        context: /home/app-source/blog  # Build context
        dockerfile: Dockerfile  # Specify an alternate Dockerfile
        args:
          - BUILD_ENV=production  # Build arguments
      container_name: blog  # Name the container
      command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
      ports:
        - "8004:8004"  # Map port 8004 on the host to port 8004 in the container
      environment:
        - ENV_VAR1=value1  # Environment variables
        - ENV_VAR2=value2
      volumes:
        - /host/path:/container/path  # Mount host directories or files
      networks:
        - project_network  # Connect to the project network
      depends_on:
        - some_other_service  # Ensure this service starts after some_other_service
      restart: always  # Restart policy (no, on-failure, always, unless-stopped)
      logging:
        driver: "json-file"  # Logging driver
        options:
          max-size: "10m"  # Maximum log file size
          max-file: "3"  # Maximum number of log files
      healthcheck:
        test: ["CMD", "curl", "-f", "http://localhost:8004"]  # Command to check service health
        interval: 1m  # Time between checks
        timeout: 10s  # Time before considering the check failed
        retries: 3  # Number of retries before marking the service as unhealthy
      labels:
        com.example.description: "Blog Service"  # Custom metadata labels
      deploy:
        replicas: 2  # Number of container instances
        resources:
          limits:
            cpus: '0.5'  # CPU limit
            memory: 512M  # Memory limit
          reservations:
            cpus: '0.25'  # CPU reservation
            memory: 256M  # Memory reservation
        restart_policy:
          condition: on-failure  # Restart policy condition
          delay: 5s  # Delay before restarting
          max_attempts: 3  # Maximum number of restart attempts
          window: 120s  # Time window for restart attempts
        placement:
          constraints:
            - node.role == manager  # Placement constraints
        update_config:
          parallelism: 2  # Number of containers to update at a time
          delay: 10s  # Delay between updates
          order: start-first  # Update order
        rollback_config:
          parallelism: 2  # Number of containers to rollback at a time
          delay: 10s  # Delay between rollbacks
      extra_hosts:
        - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
      dns:
        - 8.8.8.8  # Custom DNS servers
        - 8.8.4.4
      dns_search:
        - example.com  # Custom DNS search domains
      ulimits:
        nproc: 65535  # Set ulimits for the container
        nofile:
          soft: 20000
          hard: 40000
      cap_add:
        - NET_ADMIN  # Add Linux capabilities
      cap_drop:
        - MKNOD  # Drop Linux capabilities
      secrets:
        - my_secret  # Use Docker secrets
      configs:
        - my_config  # Use Docker configs

## ╔═══════════════════════╗
## ║       Project 5        ║
## ║   solutions Container  ║
## ╚═══════════════════════╝
  solutions:
      build:
        context: /home/app-source/solutions  # Build context
        dockerfile: Dockerfile  # Specify an alternate Dockerfile
        args:
          - BUILD_ENV=production  # Build arguments
      container_name: solutions  # Name the container
      command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
      ports:
        - "8005:8005"  # Map port 8005 on the host to port 8005 in the container
      environment:
        - ENV_VAR1=value1  # Environment variables
        - ENV_VAR2=value2
      volumes:
        - /host/path:/container/path  # Mount host directories or files
      networks:
        - project_network  # Connect to the project network
      depends_on:
        - some_other_service  # Ensure this service starts after some_other_service
      restart: always  # Restart policy (no, on-failure, always, unless-stopped)
      logging:
        driver: "json-file"  # Logging driver
        options:
          max-size: "10m"  # Maximum log file size
          max-file: "3"  # Maximum number of log files
      healthcheck:
        test: ["CMD", "curl", "-f", "http://localhost:8005"]  # Command to check service health
        interval: 1m  # Time between checks
        timeout: 10s  # Time before considering the check failed
        retries: 3  # Number of retries before marking the service as unhealthy
      labels:
        com.example.description: "Solutions Service"  # Custom metadata labels
      deploy:
        replicas: 2  # Number of container instances
        resources:
          limits:
            cpus: '0.5'  # CPU limit
            memory: 512M  # Memory limit
          reservations:
            cpus: '0.25'  # CPU reservation
            memory: 256M  # Memory reservation
        restart_policy:
          condition: on-failure  # Restart policy condition
          delay: 5s  # Delay before restarting
          max_attempts: 3  # Maximum number of restart attempts
          window: 120s  # Time window for restart attempts
        placement:
          constraints:
            - node.role == manager  # Placement constraints
        update_config:
          parallelism: 2  # Number of containers to update at a time
          delay: 10s  # Delay between updates
          order: start-first  # Update order
        rollback_config:
          parallelism: 2  # Number of containers to rollback at a time
          delay: 10s  # Delay between rollbacks
      extra_hosts:
        - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
      dns:
        - 8.8.8.8  # Custom DNS servers
        - 8.8.4.4
      dns_search:
        - example.com  # Custom DNS search domains
      ulimits:
        nproc: 65535  # Set ulimits for the container
        nofile:
          soft: 20000
          hard: 40000
      cap_add:
        - NET_ADMIN  # Add Linux capabilities
      cap_drop:
        - MKNOD  # Drop Linux capabilities
      secrets:
        - my_secret  # Use Docker secrets
      configs:
        - my_config  # Use Docker configs

## ╔═══════════════════════╗
## ║       Project 6        ║
## ║     ??? Container      ║
## ╚═══════════════════════╝
  project6:
      build:
        context: /home/app-source/project6  # Build context
        dockerfile: Dockerfile  # Specify an alternate Dockerfile
        args:
          - BUILD_ENV=production  # Build arguments
      container_name: project6  # Name the container
      command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
      ports:
        - "8006:8006"  # Map port 8006 on the host to port 8006 in the container
      environment:
        - ENV_VAR1=value1  # Environment variables
        - ENV_VAR2=value2
      volumes:
        - /host/path:/container/path  # Mount host directories or files
      networks:
        - project_network  # Connect to the project network
      depends_on:
        - some_other_service  # Ensure this service starts after some_other_service
      restart: always  # Restart policy (no, on-failure, always, unless-stopped)
      logging:
        driver: "json-file"  # Logging driver
        options:
          max-size: "10m"  # Maximum log file size
          max-file: "3"  # Maximum number of log files
      healthcheck:
        test: ["CMD", "curl", "-f", "http://localhost:8006"]  # Command to check service health
        interval: 1m  # Time between checks
        timeout: 10s  # Time before considering the check failed
        retries: 3  # Number of retries before marking the service as unhealthy
      labels:
        com.example.description: "Project6 Service"  # Custom metadata labels
      deploy:
        replicas: 2  # Number of container instances
        resources:
          limits:
            cpus: '0.5'  # CPU limit
            memory: 512M  # Memory limit
          reservations:
            cpus: '0.25'  # CPU reservation
            memory: 256M  # Memory reservation
        restart_policy:
          condition: on-failure  # Restart policy condition
          delay: 5s  # Delay before restarting
          max_attempts: 3  # Maximum number of restart attempts
          window: 120s  # Time window for restart attempts
        placement:
          constraints:
            - node.role == manager  # Placement constraints
        update_config:
          parallelism: 2  # Number of containers to update at a time
          delay: 10s  # Delay between updates
          order: start-first  # Update order
        rollback_config:
          parallelism: 2  # Number of containers to rollback at a time
          delay: 10s  # Delay between rollbacks
      extra_hosts:
        - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
      dns:
        - 8.8.8.8  # Custom DNS servers
        - 8.8.4.4
      dns_search:
        - example.com  # Custom DNS search domains
      ulimits:
        nproc: 65535  # Set ulimits for the container
        nofile:
          soft: 20000
          hard: 40000
      cap_add:
        - NET_ADMIN  # Add Linux capabilities
      cap_drop:
        - MKNOD  # Drop Linux capabilities
      secrets:
        - my_secret  # Use Docker secrets
      configs:
        - my_config  # Use Docker configs

## ╔═══════════════════════╗
## ║       Project 7        ║
## ║     wiki Container     ║
## ╚═══════════════════════╝
  project7:
    build:
      context: /home/app-source/project7  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: project7  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    ports:
      - "8007:8007"  # Map port 8007 on the host to port 8007 in the container
    environment:
      - ENV_VAR1=value1  # Environment variables
      - ENV_VAR2=value2
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
      - project_network  # Connect to the project network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8007"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "Project 7 Service"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - my_secret  # Use Docker secrets
    configs:
      - my_config  # Use Docker configs

## ╔═══════════════════════╗
## ║       Project 8        ║
## ║  ime-agent Container   ║
## ╚═══════════════════════╝
  ime-agent:
    build:
      context: /home/app-source/ime-agent  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: ime-agent  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    ports:
      - "8010:8010"  # Map port 8010 on the host to port 8010 in the container
    environment:
      - MODEL_PATH=/home/app-source/ime-agent/models/ime_model  # Environment variables
      - ENV_VAR1=value1
      - ENV_VAR2=value2
    volumes:
      - ime_model_data:/home/app-source/ime-agent/models  # Mount host directories or files
    networks:
      - project_network  # Connect to the project network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8010"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "IME Agent Service"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '4'  # CPU limit
          memory: 8G  # Memory limit
        reservations:
          cpus: '2'  # CPU reservation
          memory: 4G  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - my_secret  # Use Docker secrets
    configs:
      - my_config  # Use Docker configs

## ╔═══════════════════════╗
## ║       Project 9        ║
## ║     wiki Container     ║
## ╚═══════════════════════╝
  wiki:
    build:
      context: /home/app-source/wiki  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: wiki  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    ports:
      - "8009:8009"  # Map port 8009 on the host to port 8009 in the container
    environment:
      - ENV_VAR1=value1  # Environment variables
      - ENV_VAR2=value2
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
      - project_network  # Connect to the project network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8009"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "Wiki Service"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - my_secret  # Use Docker secrets
    configs:
      - my_config  # Use Docker configs

## ╔═══════════════════════╗
## ║       Project 10       ║
## ║     ??? Container      ║
## ╚═══════════════════════╝
  project10:
    build:
      context: /home/app-source/project10  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: project10  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    ports:
      - "8010:8010"  # Map port 8010 on the host to port 8010 in the container
    environment:
      - ENV_VAR1=value1  # Environment variables
      - ENV_VAR2=value2
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
      - project_network  # Connect to the project network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8010"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "Project 10 Service"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - my_secret  # Use Docker secrets
    configs:
      - my_config  # Use Docker configs

## ╔═══════════════════════╗
## ║      Project 11        ║
## ║   ime-nft Container    ║
## ╚═══════════════════════╝
  ime-nft:
    build:
      context: /home/app-source/ime-nft  # Build context
      dockerfile: Dockerfile  # Specify an alternate Dockerfile
      args:
        - BUILD_ENV=production  # Build arguments
    container_name: ime-nft  # Name the container
    command: ["your_start_command", "arg1", "arg2"]  # Command to start the service
    ports:
      - "8011:8011"  # Map port 8011 on the host to port 8011 in the container
    environment:
      - ENV_VAR1=value1  # Environment variables
      - ENV_VAR2=value2
    volumes:
      - /host/path:/container/path  # Mount host directories or files
    networks:
      - project_network  # Connect to the project network
    depends_on:
      - some_other_service  # Ensure this service starts after some_other_service
    restart: always  # Restart policy (no, on-failure, always, unless-stopped)
    logging:
      driver: "json-file"  # Logging driver
      options:
        max-size: "10m"  # Maximum log file size
        max-file: "3"  # Maximum number of log files
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8011"]  # Command to check service health
      interval: 1m  # Time between checks
      timeout: 10s  # Time before considering the check failed
      retries: 3  # Number of retries before marking the service as unhealthy
    labels:
      com.example.description: "IME NFT Service"  # Custom metadata labels
    deploy:
      replicas: 2  # Number of container instances
      resources:
        limits:
          cpus: '0.5'  # CPU limit
          memory: 512M  # Memory limit
        reservations:
          cpus: '0.25'  # CPU reservation
          memory: 256M  # Memory reservation
      restart_policy:
        condition: on-failure  # Restart policy condition
        delay: 5s  # Delay before restarting
        max_attempts: 3  # Maximum number of restart attempts
        window: 120s  # Time window for restart attempts
      placement:
        constraints:
          - node.role == manager  # Placement constraints
      update_config:
        parallelism: 2  # Number of containers to update at a time
        delay: 10s  # Delay between updates
        order: start-first  # Update order
      rollback_config:
        parallelism: 2  # Number of containers to rollback at a time
        delay: 10s  # Delay between rollbacks
    extra_hosts:
      - "somehost:162.242.195.82"  # Add entries to container's /etc/hosts file
    dns:
      - 8.8.8.8  # Custom DNS servers
      - 8.8.4.4
    dns_search:
      - example.com  # Custom DNS search domains
    ulimits:
      nproc: 65535  # Set ulimits for the container
      nofile:
        soft: 20000
        hard: 40000
    cap_add:
      - NET_ADMIN  # Add Linux capabilities
    cap_drop:
      - MKNOD  # Drop Linux capabilities
    secrets:
      - my_secret  # Use Docker secrets
    configs:
      - my_config  # Use Docker configs




# Define networks
networks:
  main_network:
    driver: bridge  # Network driver
  project_network:
    driver: bridge  # Network driver

secrets:
  my_secret:
    file: ./secret.txt  # File containing the secret

configs:
  my_config:
    file: ./config.json  # File containing the configuration

# Define volumes
volumes:
  mysql_data:
  postgres_data:
  ime_model_data:
